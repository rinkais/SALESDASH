import logging
import hashlib
import random
import zoneinfo
import requests
from datetime import datetime, date, timedelta, time
from telegram import Update, ReplyKeyboardRemove, ReplyKeyboardMarkup, KeyboardButton
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
from telegram.constants import ParseMode
from telegram.helpers import escape_markdown


logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO
)
logger = logging.getLogger(__name__)

ENTER_IIKO_SERVER_ADDRESS = 1
ENTER_IIKO_LOGIN = 2
ENTER_IIKO_PASSWORD = 3
MAIN_MENU = 4
REPORT_MENU = 5

LOADING_MESSAGES = [
    "–°–µ–∫—É–Ω–¥—É, —Ñ–æ—Ä–º–∏—Ä—É—é –≤–∞—à –æ—Ç—á–µ—Ç... –≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –Ω–µ–º–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏. ‚è≥",
    "–ò–¥–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö... üìä –ü–æ–¥–æ–∂–¥–∏—Ç–µ –Ω–µ–º–Ω–æ–≥–æ, —Å–∫–æ—Ä–æ –≤—Å—ë –±—É–¥–µ—Ç –≥–æ—Ç–æ–≤–æ!",
    "–ó–∞–≥—Ä—É–∂–∞—é –æ—Ç—á–µ—Ç... ‚è≥",
    "–°–µ–π—á–∞—Å –ø–æ–¥–≥–æ—Ç–æ–≤–ª—é –≤–∞—à –æ—Ç—á–µ—Ç, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ –Ω–µ–º–Ω–æ–≥–æ! üöÄ",
    "–ò–¥–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö... üìä –ü–æ–¥–æ–∂–¥–∏—Ç–µ –Ω–µ–º–Ω–æ–≥–æ, —Å–∫–æ—Ä–æ –≤—Å—ë –±—É–¥–µ—Ç –≥–æ—Ç–æ–≤–æ!"
]

IIKO_TIMEZONE = zoneinfo.ZoneInfo("Asia/Yekaterinburg")
SHIFT_HOUR = 6  # –Ω–∞—á–∞–ª–æ –¥–Ω—è –≤ 06:00
SHIFT_MINUTE = 0

def get_period_dates(period_name: str) -> tuple[datetime, datetime]:
    now = datetime.now(IIKO_TIMEZONE)
    today = now.date()

    if "–°–µ–≥–æ–¥–Ω—è" in period_name:
        day = today
        start = datetime.combine(day, time(hour=SHIFT_HOUR, minute=SHIFT_MINUTE), tzinfo=IIKO_TIMEZONE)
        end = datetime.combine(day, time(hour=23, minute=59, second=59), tzinfo=IIKO_TIMEZONE)
    elif "–í—á–µ—Ä–∞" in period_name:
        day = today - timedelta(days=1)
        start = datetime.combine(day, time(hour=SHIFT_HOUR, minute=SHIFT_MINUTE), tzinfo=IIKO_TIMEZONE)
        end = datetime.combine(day, time(hour=23, minute=59, second=59), tzinfo=IIKO_TIMEZONE)
    elif "–ù–µ–¥–µ–ª—è" in period_name:
        start_day = today - timedelta(days=6)
        start = datetime.combine(start_day, time(hour=SHIFT_HOUR, minute=SHIFT_MINUTE), tzinfo=IIKO_TIMEZONE)
        end = datetime.combine(today, time(hour=23, minute=59, second=59), tzinfo=IIKO_TIMEZONE)
    elif "–¢–µ–∫—É—â–∏–π –º–µ—Å—è—Ü" in period_name:
        first_day = today.replace(day=1)
        start = datetime.combine(first_day, time(hour=SHIFT_HOUR, minute=SHIFT_MINUTE), tzinfo=IIKO_TIMEZONE)
        end = datetime.combine(today, time(hour=23, minute=59, second=59), tzinfo=IIKO_TIMEZONE)
    elif "–ü—Ä–æ—à–ª—ã–π –º–µ—Å—è—Ü" in period_name:
        first_day_this_month = today.replace(day=1)
        last_day_last_month = first_day_this_month - timedelta(days=1)
        first_day_last_month = last_day_last_month.replace(day=1)
        start = datetime.combine(first_day_last_month, time(hour=SHIFT_HOUR, minute=SHIFT_MINUTE), tzinfo=IIKO_TIMEZONE)
        end = datetime.combine(last_day_last_month, time(hour=23, minute=59, second=59), tzinfo=IIKO_TIMEZONE)
    else:
        day = today
        start = datetime.combine(day, time(hour=SHIFT_HOUR, minute=SHIFT_MINUTE), tzinfo=IIKO_TIMEZONE)
        end = datetime.combine(day, time(hour=23, minute=59, second=59), tzinfo=IIKO_TIMEZONE)

    return start, end

from datetime import timedelta

async def get_average_check(iiko_server_url: str, iiko_session_token: str, start_date: date, end_date: date) -> dict | None:
    report_url = f"{iiko_server_url}api/v2/reports/olap"
    headers = {
        'Content-Type': 'application/json',
        'Cookie': f'key={iiko_session_token}'
    }
    payload = {
        "reportType": "SALES",
        "groupByRowFields": [],
        "aggregateFields": ["DishDiscountSumInt", "UniqOrderId"],
        "filters": {
            "OpenDate.Typed": {
                "filterType": "DateRange",
                "periodType": "CUSTOM",
                "from": start_date.strftime("%Y-%m-%dT00:00:00.000"),
                "to": (end_date + timedelta(days=1)).strftime("%Y-%m-%dT00:00:00.000")
            },
            "DeletedWithWriteoff": {
                "filterType": "ExcludeValues",
                "values": ["DELETED_WITH_WRITEOFF", "DELETED_WITHOUT_WRITEOFF"]
            },
            "OrderDeleted": {
                "filterType": "IncludeValues",
                "values": ["NOT_DELETED"]
            }
        }
    }
    try:
        import requests
        response = requests.post(report_url, headers=headers, json=payload, timeout=30)
        response.raise_for_status()
        data = response.json()
        if data and data.get('data') and isinstance(data['data'], list) and len(data['data']) > 0:
            row = data['data'][0]
            total_sum = row.get('DishDiscountSumInt', 0)
            order_count = row.get('UniqOrderId', 0)
            avg_check = total_sum / order_count if order_count else 0
            return {
                "total_sum": total_sum,
                "order_count": order_count,
                "avg_check": avg_check
            }
        return None
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –æ—Ç—á–µ—Ç–∞ '–°—Ä–µ–¥–Ω–∏–π —á–µ–∫': {e}, –æ—Ç–≤–µ—Ç: {getattr(response, 'text', '')}")
        return None

async def get_order_cancellations_and_deleted_dishes(
    iiko_server_url: str, iiko_session_token: str,
    start_date, end_date
) -> list | None:
    report_url = f"{iiko_server_url}api/v2/reports/olap"
    headers = {
        'Content-Type': 'application/json',
        'Cookie': f'key={iiko_session_token}'
    }
    payload = {
        "reportType": "SALES",
        "groupByRowFields": [
            "Department",
            "OpenDate.Typed",
            "OrderDeleted",
            "DeletedWithWriteoff",
            "OrderNum",
            "OrderType",
            "OpenTime",
            "AuthUser",
            "Delivery.CancelCause",
            "RemovalType",
            "Delivery.CancelComment",
            "DeletionComment"
        ],
        "aggregateFields": [
            "DishReturnSum",
            "DishSumInt"
        ],
        "filters": {
            "OpenDate.Typed": {
                "filterType": "DateRange",
                "periodType": "CUSTOM",
                "from": start_date.strftime("%Y-%m-%dT00:00:00.000"),
                "to": (end_date + timedelta(days=1)).strftime("%Y-%m-%dT00:00:00.000")
            },
            "DeletedWithWriteoff": {
                "filterType": "IncludeValues",
                "values": [
                    "DELETED_WITH_WRITEOFF",
                    "DELETED_WITHOUT_WRITEOFF",
                    None
                ]
            },
            "RemovalType": {
                "filterType": "IncludeValues",
                "values": [
                    "–°–æ —Å–ø–∏—Å–∞–Ω–∏–µ–º",
                    "–ë–µ–∑ —Å–ø–∏—Å–∞–Ω–∏—è"
                ]
            }
        }
    }
    try:
        import requests
        response = requests.post(report_url, headers=headers, json=payload, timeout=30)
        response.raise_for_status()
        data = response.json()
        if data and data.get("data") and isinstance(data["data"], list) and len(data["data"]) > 0:
            return data["data"]
        return None
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –æ—Ç—á–µ—Ç–∞ '–û—Ç–º–µ–Ω—ã –∏ —É–¥–∞–ª–µ–Ω–∏—è': {e}, –æ—Ç–≤–µ—Ç: {getattr(response, 'text', '')}")
        return None

async def get_store_balances(iiko_server_url: str, iiko_session_token: str) -> list | None:
    now = datetime.now(IIKO_TIMEZONE)
    end_of_day = datetime.combine(now.date(), time(hour=23, minute=59, second=59), tzinfo=IIKO_TIMEZONE)
    timestamp = end_of_day.strftime("%Y-%m-%dT%H:%M:%S")

    url = f"{iiko_server_url}api/v2/reports/balance/stores"
    params = {
        "key": iiko_session_token,
        "timestamp": timestamp
    }
    try:
        response = requests.get(url, params=params, timeout=30)
        response.raise_for_status()
        data = response.json()
        return data
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –æ—Å—Ç–∞—Ç–∫–∞ –ø–æ —Å–∫–ª–∞–¥–∞–º: {e}")
        return None



def sha1_hash(text: str) -> str:
    return hashlib.sha1(text.encode('utf-8')).hexdigest()

async def authenticate_iiko_server(server_url: str, login: str, password_hash: str) -> str | None:
    auth_url = f"{server_url}api/auth?login={login}&pass={password_hash}"
    logger.info(f"Attempting to authenticate to iikoServer API at {auth_url} with login: {login}...")
    try:
        response = requests.get(auth_url, timeout=10)
        response.raise_for_status()
        token = response.text.strip()
        if token:
            logger.info(f"Successfully received iikoServer token.")
            return token
        else:
            logger.warning(f"iikoServer API response did not contain a token. Response: {response.text}")
            return None
    except Exception as e:
        logger.error(f"Error during iikoServer authentication: {str(e)}")
        return None

async def get_pay_types_revenue_from_iiko_server(iiko_server_url: str, iiko_session_token: str, start_date: date, end_date: date) -> dict | None:
    report_url = f"{iiko_server_url}api/v2/reports/olap"
    headers = {
        'Content-Type': 'application/json',
        'Cookie': f'key={iiko_session_token}'
    }
    start_date_str = start_date.strftime("%Y-%m-%dT00:00:00.000")
    end_date_str = (end_date + timedelta(days=1)).strftime("%Y-%m-%dT00:00:00.000")
    payload = {
        "reportType": "SALES",
        "groupByRowFields": [
            "OpenDate.Typed",
            "PayTypes"
        ],
        "aggregateFields": [
            "DishSumInt",
            "DishDiscountSumInt",
            "UniqOrderId"
        ],
        "filters": {
            "OpenDate.Typed": {
                "filterType": "DateRange",
                "periodType": "CUSTOM",
                "from": start_date_str,
                "to": end_date_str
            },
            "DeletedWithWriteoff": {
                "filterType": "ExcludeValues",
                "values": ["DELETED_WITH_WRITEOFF", "DELETED_WITHOUT_WRITEOFF"]
            },
            "OrderDeleted": {
                "filterType": "IncludeValues",
                "values": ["NOT_DELETED"]
            }
        }
    }
    logger.info(f"Attempting to get 'Revenue by Payment Types' report from iikoServer API v2 at {report_url} (from {start_date_str} to {end_date_str})...")
    try:
        response = requests.post(report_url, headers=headers, json=payload, timeout=30)
        response.raise_for_status()
        data = response.json()
        total_revenue_overall = 0.0
        total_order_count_overall = 0
        sales_by_payment_type = {}
        if data and data.get('data') and isinstance(data['data'], list):
            for row in data['data']:
                payment_type = row.get('PayTypes', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø –æ–ø–ª–∞—Ç—ã')
                sales_sum = row.get('DishDiscountSumInt', 0.0)
                order_count = row.get('UniqOrderId', 0)
                total_revenue_overall += sales_sum
                total_order_count_overall += order_count
                if payment_type:
                    sales_by_payment_type[payment_type] = sales_by_payment_type.get(payment_type, 0.0) + sales_sum
                else:
                    sales_by_payment_type['–î—Ä—É–≥–∏–µ/–ù–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–µ'] = sales_by_payment_type.get('–î—Ä—É–≥–∏–µ/–ù–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–µ', 0.0) + sales_sum
            logger.info(f"Successfully received and processed 'Revenue by Payment Types' report from iikoServer API v2 for period {start_date} to {end_date}.")
            if total_revenue_overall == 0 and total_order_count_overall == 0:
                logger.info("No revenue data found for the specified date range in the iikoServer report after filtering.")
                return None
            return {
                'total_revenue_overall': total_revenue_overall,
                'total_order_count_overall': total_order_count_overall,
                'sales_by_payment_type': sales_by_payment_type,
            }
        else:
            logger.warning(f"iikoServer API response for 'Revenue by Payment Types' report v2 did not contain expected 'data' list: {data}")
            return None
    except Exception as e:
        logger.error(f"Exception in get_pay_types_revenue_from_iiko_server: {e}")
        return None

async def get_discounts_and_markups_report(iiko_server_url: str, iiko_session_token: str, start_date: date, end_date: date) -> list | None:
    report_url = f"{iiko_server_url}api/v2/reports/olap"
    headers = {
        'Content-Type': 'application/json',
        'Cookie': f'key={iiko_session_token}'
    }
    payload = {
        "reportType": "SALES",
        "groupByRowFields": ["OrderDiscount.Type", "OrderIncrease.Type"],
        "aggregateFields": ["DiscountSum", "IncreaseSum", "OrderNum"],
        "filters": {
            "OpenDate.Typed": {
                "filterType": "DateRange",
                "periodType": "CUSTOM",
                "from": start_date.strftime("%Y-%m-%dT00:00:00.000"),
                "to": (end_date + timedelta(days=1)).strftime("%Y-%m-%dT00:00:00.000")
            },
            "DeletedWithWriteoff": {
                "filterType": "ExcludeValues",
                "values": ["DELETED_WITH_WRITEOFF", "DELETED_WITHOUT_WRITEOFF"]
            },
            "OrderDeleted": {
                "filterType": "IncludeValues",
                "values": ["NOT_DELETED"]
            }
        }
    }
    try:
        response = requests.post(report_url, headers=headers, json=payload, timeout=30)
        response.raise_for_status()
        data = response.json()
        results = []
        if data and data.get('data') and isinstance(data['data'], list):
            for row in data['data']:
                discount = row.get('OrderDiscount.Type')
                increase = row.get('OrderIncrease.Type')
                discount_sum = row.get('DiscountSum', 0.0)
                increase_sum = row.get('IncreaseSum', 0.0)
                order_count = row.get('OrderNum', 0)
                if discount:
                    results.append({
                        "type": "–°–∫–∏–¥–∫–∞",
                        "name": discount,
                        "sum": discount_sum,
                        "orders": order_count
                    })
                if increase:
                    results.append({
                        "type": "–ù–∞–¥–±–∞–≤–∫–∞",
                        "name": increase,
                        "sum": increase_sum,
                        "orders": order_count
                    })
            return results
        return None
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –æ—Ç—á–µ—Ç–∞ '–°–∫–∏–¥–∫–∏ –∏ –Ω–∞–¥–±–∞–≤–∫–∏': {e}, –æ—Ç–≤–µ—Ç: {getattr(response, 'text', '')}")
        return None



async def get_dish_category_revenue_from_iiko_server(iiko_server_url: str, iiko_session_token: str, start_date: date, end_date: date) -> dict | None:
    report_url = f"{iiko_server_url}api/v2/reports/olap"
    headers = {
        'Content-Type': 'application/json',
        'Cookie': f'key={iiko_session_token}'
    }
    start_date_str = start_date.strftime("%Y-%m-%dT00:00:00.000")
    end_date_str = (end_date + timedelta(days=1)).strftime("%Y-%m-%dT00:00:00.000")
    payload = {
        "reportType": "SALES",
        "groupByRowFields": ["DishCategory"],
        "aggregateFields": ["DishSumInt", "DishDiscountSumInt", "UniqOrderId"],
        "filters": {
            "OpenDate.Typed": {"filterType": "DateRange", "periodType": "CUSTOM", "from": start_date_str, "to": end_date_str},
            "DeletedWithWriteoff": {"filterType": "IncludeValues", "values": ["NOT_DELETED"]},
            "OrderDeleted": {"filterType": "IncludeValues", "values": ["NOT_DELETED"]}
        }
    }
    logger.info(f"Attempting to get 'Revenue by Dish Category' report from iikoServer API v2 at {report_url} (from {start_date_str} to {end_date_str})...")
    try:
        response = requests.post(report_url, headers=headers, json=payload, timeout=30)
        response.raise_for_status()
        data = response.json()
        total_revenue_overall = 0.0
        total_order_count_overall = 0
        sales_by_category = {}
        if data and data.get('data') and isinstance(data['data'], list):
            for row in data['data']:
                dish_category = row.get('DishCategory', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–∞—Ç–µ–≥–æ—Ä–∏—è')
                sales_sum = row.get('DishDiscountSumInt', 0.0)
                order_count = row.get('UniqOrderId', 0)
                total_revenue_overall += sales_sum
                total_order_count_overall += order_count
                if dish_category:
                    sales_by_category[dish_category] = sales_by_category.get(dish_category, 0.0) + sales_sum
                else:
                    sales_by_category['–î—Ä—É–≥–∏–µ/–ù–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–µ'] = sales_by_category.get('–î—Ä—É–≥–∏–µ/–ù–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–µ', 0.0) + sales_sum
            logger.info(f"Successfully received and processed 'Revenue by Dish Category' report from iikoServer API v2 for period {start_date} to {end_date}.")
            if total_revenue_overall == 0 and total_order_count_overall == 0:
                logger.info("No revenue data found for the specified date range in the iikoServer report after filtering by dish category.")
                return None
            return {
                'total_revenue_overall': total_revenue_overall,
                'total_order_count_overall': total_order_count_overall,
                'sales_by_category': sales_by_category,
            }
        else:
            logger.warning(f"iikoServer API response for 'Revenue by Dish Category' report v2 did not contain expected 'data' list: {data}")
            return None
    except Exception as e:
        logger.error(f"Exception in get_dish_category_revenue_from_iiko_server: {e}")
        return None







async def get_waiter_revenue_from_iiko_server(iiko_server_url: str, iiko_session_token: str, start_date: date, end_date: date) -> dict | None:
    report_url = f"{iiko_server_url}api/v2/reports/olap"
    headers = {
        'Content-Type': 'application/json',
        'Cookie': f'key={iiko_session_token}'
    }
    start_date_str = start_date.strftime("%Y-%m-%dT00:00:00.000")
    end_date_str = (end_date + timedelta(days=1)).strftime("%Y-%m-%dT00:00:00.000")
    payload = {
        "reportType": "SALES",
        "groupByRowFields": ["WaiterName"],
        "aggregateFields": ["DishSumInt", "DishDiscountSumInt"],
        "filters": {
            "OpenDate.Typed": {"filterType": "DateRange", "periodType": "CUSTOM", "from": start_date_str, "to": end_date_str},
            "DeletedWithWriteoff": {"filterType": "IncludeValues", "values": ["NOT_DELETED"]},
            "OrderDeleted": {"filterType": "IncludeValues", "values": ["NOT_DELETED"]}
        }
    }
    logger.info(f"Attempting to get 'Revenue by Waiter' report from iikoServer API v2 at {report_url} (from {start_date_str} to {end_date_str})...")
    try:
        response = requests.post(report_url, headers=headers, json=payload, timeout=30)
        response.raise_for_status()
        data = response.json()
        total_revenue_overall = 0.0
        sales_by_waiter = {}
        if data and data.get('data') and isinstance(data['data'], list):
            for row in data['data']:
                waiter_name = row.get('WaiterName', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –æ—Ñ–∏—Ü–∏–∞–Ω—Ç')
                sales_sum = row.get('DishDiscountSumInt', 0.0)
                total_revenue_overall += sales_sum
                if waiter_name:
                    sales_by_waiter[waiter_name] = sales_by_waiter.get(waiter_name, 0.0) + sales_sum
                else:
                    sales_by_waiter['–î—Ä—É–≥–∏–µ/–ù–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–µ'] = sales_by_waiter.get('–î—Ä—É–≥–∏–µ/–ù–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–µ', 0.0) + sales_sum
            logger.info(f"Successfully received and processed 'Revenue by Waiter' report from iikoServer API v2 for period {start_date} to {end_date}.")
            if total_revenue_overall == 0:
                logger.info("No revenue data found for the specified date range in the iikoServer report after filtering by waiter.")
                return None
            return {'total_revenue_overall': total_revenue_overall, 'sales_by_waiter': sales_by_waiter}
        else:
            logger.warning(f"iikoServer API response for 'Revenue by Waiter' report v2 did not contain expected 'data' list: {data}")
            return None
    except Exception as e:
        logger.error(f"Exception in get_waiter_revenue_from_iiko_server: {e}")
        return None

async def get_order_type_revenue_from_iiko_server(iiko_server_url: str, iiko_session_token: str, start_date: date, end_date: date) -> dict | None:
    report_url = f"{iiko_server_url}api/v2/reports/olap"
    headers = {
        'Content-Type': 'application/json',
        'Cookie': f'key={iiko_session_token}'
    }
    start_date_str = start_date.strftime("%Y-%m-%dT00:00:00.000")
    end_date_str = (end_date + timedelta(days=1)).strftime("%Y-%m-%dT00:00:00.000")
    payload = {
        "reportType": "SALES",
        "groupByRowFields": ["OrderType"],
        "aggregateFields": ["DishSumInt", "DishDiscountSumInt", "UniqOrderId"],
        "filters": {
            "OpenDate.Typed": {"filterType": "DateRange", "periodType": "CUSTOM", "from": start_date_str, "to": end_date_str},
            "DeletedWithWriteoff": {"filterType": "IncludeValues", "values": ["NOT_DELETED"]},
            "OrderDeleted": {"filterType": "IncludeValues", "values": ["NOT_DELETED"]}
        }
    }
    logger.info(f"Attempting to get 'Revenue by Order Type' report from iikoServer API v2 at {report_url} (from {start_date_str} to {end_date_str})...")
    try:
        response = requests.post(report_url, headers=headers, json=payload, timeout=30)
        response.raise_for_status()
        data = response.json()
        total_revenue_overall = 0.0
        total_order_count_overall = 0
        sales_by_order_type = {}
        order_count_by_type = {}
        if data and data.get('data') and isinstance(data['data'], list):
            for row in data['data']:
                order_type = row.get('OrderType')
                sales_sum = row.get('DishDiscountSumInt', 0.0)
                order_count = row.get('UniqOrderId', 0)
                total_revenue_overall += sales_sum
                total_order_count_overall += order_count
                if not order_type:
                    order_type_display = "–ó–∞–∫–∞–∑—ã –≤ –∑–∞–≤–µ–¥–µ–Ω–∏–∏"
                else:
                    order_type_display = order_type
                sales_by_order_type[order_type_display] = sales_by_order_type.get(order_type_display, 0.0) + sales_sum
                order_count_by_type[order_type_display] = order_count_by_type.get(order_type_display, 0) + order_count
            logger.info(f"Successfully received and processed 'Revenue by Order Type' report from iikoServer API v2 for period {start_date} to {end_date}.")
            if total_revenue_overall == 0 and total_order_count_overall == 0:
                logger.info("No revenue data found for the specified date range in the iikoServer report after filtering by order type.")
                return None
            return {
                'total_revenue_overall': total_revenue_overall,
                'total_order_count_overall': total_order_count_overall,
                'sales_by_order_type': sales_by_order_type,
                'order_count_by_type': order_count_by_type,
            }
        else:
            logger.warning(f"iikoServer API response for 'Revenue by Order Type' report v2 did not contain expected 'data' list: {data}")
            return None
    except Exception as e:
        logger.error(f"Exception in get_order_type_revenue_from_iiko_server: {e}")
        return None

async def get_summary_revenue_report_data(iiko_server_url: str, iiko_session_token: str, start_date: date, end_date: date) -> dict:
    summary_data = {
        'start_date': start_date.strftime('%d.%m.%Y'),
        'end_date': end_date.strftime('%d.%m.%Y'),
        'pay_types_revenue': None,
        'dish_category_revenue': None,
        'waiter_revenue': None,
        'order_type_revenue': None,
    }
    pay_types_data = await get_pay_types_revenue_from_iiko_server(iiko_server_url, iiko_session_token, start_date, end_date)
    if pay_types_data:
        summary_data['pay_types_revenue'] = pay_types_data
    dish_category_data = await get_dish_category_revenue_from_iiko_server(iiko_server_url, iiko_session_token, start_date, end_date)
    if dish_category_data:
        summary_data['dish_category_revenue'] = dish_category_data
    waiter_data = await get_waiter_revenue_from_iiko_server(iiko_server_url, iiko_session_token, start_date, end_date)
    if waiter_data:
        summary_data['waiter_revenue'] = waiter_data
    order_type_data = await get_order_type_revenue_from_iiko_server(iiko_server_url, iiko_session_token, start_date, end_date)
    if order_type_data:
        summary_data['order_type_revenue'] = order_type_data
    return summary_data

async def show_pay_types_revenue_report(update: Update, context: ContextTypes.DEFAULT_TYPE, start_date: date, end_date: date) -> None:
    iiko_session_token = context.user_data.get('iiko_session_token')
    iiko_server_address = context.user_data.get('iiko_server_address')
    if not iiko_session_token or not iiko_server_address:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–Ω–∞—á–∞–ª–∞ –∞–≤—Ç–æ—Ä–∏–∑—É–π—Ç–µ—Å—å –≤ iikoServer API, –∏—Å–ø–æ–ª—å–∑—É—è –∫–æ–º–∞–Ω–¥—É `/start`.")
        return
    loading_message = random.choice(LOADING_MESSAGES)
    await update.message.reply_text(loading_message)
    revenue_data = await get_pay_types_revenue_from_iiko_server(iiko_server_address, iiko_session_token, start_date, end_date)
    period_str = f"{start_date.strftime('%d.%m.%Y')} - {end_date.strftime('%d.%m.%Y')}"
    if start_date == end_date:
        period_str = start_date.strftime('%d.%m.%Y')
    if revenue_data:
        response_text = (
            f"üìä *–û—Ç—á–µ—Ç: –í—ã—Ä—É—á–∫–∞ –ø–æ —Ç–∏–ø–∞–º –æ–ø–ª–∞—Ç –∑–∞ {escape_markdown(period_str, version=2)}*\n\n"
            f"üßæ –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–∫–∞–∑–æ–≤: *{escape_markdown(str(revenue_data['total_order_count_overall']), version=2)}* —à—Ç\\.\n"
            f"üí∞ –û–±—â–∞—è –≤—ã—Ä—É—á–∫–∞: *{escape_markdown(f'{revenue_data['total_revenue_overall']:.2f}', version=2)}* —Ç–≥\\.\n\n"
            f"_{escape_markdown('–î–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ —Ç–∏–ø–∞–º –æ–ø–ª–∞—Ç:', version=2)}_\n"
        )
        sorted_payment_types = sorted(revenue_data['sales_by_payment_type'].items(), key=lambda item: item[0])
        for payment_type, amount in sorted_payment_types:
            escaped_payment_type = escape_markdown(payment_type, version=2)
            escaped_amount = escape_markdown(f'{amount:.2f}', version=2)
            response_text += f"‚ñ™Ô∏è {escaped_payment_type}: *{escaped_amount}* —Ç–≥\\.\n"
        await update.message.reply_text(response_text, parse_mode=ParseMode.MARKDOWN_V2)
    else:
        await update.message.reply_text(
            f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –æ—Ç—á–µ—Ç '–í—ã—Ä—É—á–∫–∞ –ø–æ —Ç–∏–ø–∞–º –æ–ø–ª–∞—Ç' –∑–∞ –ø–µ—Ä–∏–æ–¥ *{escape_markdown(period_str, version=2)}* —Å —Å–µ—Ä–≤–µ—Ä–∞ *{escape_markdown(iiko_server_address, version=2)}*\\.\n"
            "–í–æ–∑–º–æ–∂–Ω–æ, –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –∑–∞ —É–∫–∞–∑–∞–Ω–Ω—ã–π –ø–µ—Ä–∏–æ–¥, –∏–ª–∏ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –≤ API iikoServer\\. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏ –±–æ—Ç–∞\\.",
            parse_mode=ParseMode.MARKDOWN_V2,
        )

async def show_order_cancellations_report(update, context, start_date, end_date):
    iiko_session_token = context.user_data.get('iiko_session_token')
    iiko_server_address = context.user_data.get('iiko_server_address')
    if not iiko_session_token or not iiko_server_address:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–Ω–∞—á–∞–ª–∞ –∞–≤—Ç–æ—Ä–∏–∑—É–π—Ç–µ—Å—å –≤ iikoServer API –∫–æ–º–∞–Ω–¥–æ–π /start.")
        return

    LOADING_MESSAGES = [
        "–°–µ–∫—É–Ω–¥—É, —Ñ–æ—Ä–º–∏—Ä—É—é –≤–∞—à –æ—Ç—á–µ—Ç... –≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –Ω–µ–º–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏. ‚è≥",
        "–ò–¥–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö... üìä –ü–æ–¥–æ–∂–¥–∏—Ç–µ –Ω–µ–º–Ω–æ–≥–æ, —Å–∫–æ—Ä–æ –≤—Å—ë –±—É–¥–µ—Ç –≥–æ—Ç–æ–≤–æ!",
        "–ó–∞–≥—Ä—É–∂–∞—é –æ—Ç—á–µ—Ç... ‚è≥",
        "–°–µ–π—á–∞—Å –ø–æ–¥–≥–æ—Ç–æ–≤–ª—é –≤–∞—à –æ—Ç—á–µ—Ç, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ –Ω–µ–º–Ω–æ–≥–æ! üöÄ",
        "–ò–¥–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö... üìä –ü–æ–¥–æ–∂–¥–∏—Ç–µ –Ω–µ–º–Ω–æ–≥–æ, —Å–∫–æ—Ä–æ –≤—Å—ë –±—É–¥–µ—Ç –≥–æ—Ç–æ–≤–æ!"
    ]
    loading_message = random.choice(LOADING_MESSAGES)
    await update.message.reply_text(loading_message)

    data = await get_order_cancellations_and_deleted_dishes(
        iiko_server_address, iiko_session_token, start_date, end_date
    )
    period_str = f"{start_date.strftime('%d.%m.%Y')} - {end_date.strftime('%d.%m.%Y')}"
    if start_date == end_date:
        period_str = start_date.strftime('%d.%m.%Y')
    if data:
        header = f"üìã *–û—Ç—á–µ—Ç –ø–æ –æ—Ç–º–µ–Ω–∞–º/—É–¥–∞–ª–µ–Ω–∏—è–º –∑–∞ {escape_markdown(period_str, version=2)}*\n"
        lines = [header]
        for idx, row in enumerate(data, 1):
            dept = escape_markdown(str(row.get("Department", "")), version=2)
            date = escape_markdown(str(row.get("OpenDate.Typed", "")), version=2)
            order_num = escape_markdown(str(row.get("OrderNum", "")), version=2)
            deleted_status = escape_markdown(str(row.get("DeletedWithWriteoff", "")), version=2)
            removal_type = escape_markdown(str(row.get("RemovalType", "")), version=2)
            dish_sum = escape_markdown(str(row.get("DishSumInt", 0)), version=2)
            return_sum = escape_markdown(str(row.get("DishReturnSum", 0)), version=2)
            comment = escape_markdown(str(row.get("DeletionComment", "")), version=2)
            cause = escape_markdown(str(row.get("Delivery.CancelCause", "")), version=2)
            order_type = escape_markdown(str(row.get("OrderType", "")), version=2)
            auth_user = escape_markdown(str(row.get("AuthUser", "")), version=2)

            lines.append(
                f"{idx}\\.\ {dept}, {date}, —á–µ–∫: {order_num}, {order_type}, {deleted_status}, {removal_type}, —Å—É–º–º–∞: {dish_sum}, –≤–æ–∑–≤—Ä–∞—Ç: {return_sum}, –ø—Ä–∏—á–∏–Ω–∞: {cause}, –∫–æ–º–º–µ–Ω—Ç: {comment}, –∞–≤—Ç–æ—Ä: {auth_user}"
            )
        response = "\n".join(lines)
        await update.message.reply_text(response, parse_mode=ParseMode.MARKDOWN_V2)
    else:
        await update.message.reply_text(
            f"–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –ø–æ –æ—Ç–º–µ–Ω–∞–º/—É–¥–∞–ª–µ–Ω–∏—è–º –∑–∞ –ø–µ—Ä–∏–æ–¥ *{escape_markdown(period_str, version=2)}*.",
            parse_mode=ParseMode.MARKDOWN_V2
        )

async def show_average_check_report(update, context, start_date, end_date):
    from telegram.constants import ParseMode
    from telegram.helpers import escape_markdown
    import random

    LOADING_MESSAGES = [
        "–°–µ–∫—É–Ω–¥—É, —Ñ–æ—Ä–º–∏—Ä—É—é –≤–∞—à –æ—Ç—á–µ—Ç... –≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –Ω–µ–º–Ω–æ–≥–æ –≤—Ä–µ–º–µ–Ω–∏. ‚è≥",
        "–ò–¥–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö... üìä –ü–æ–¥–æ–∂–¥–∏—Ç–µ –Ω–µ–º–Ω–æ–≥–æ, —Å–∫–æ—Ä–æ –≤—Å—ë –±—É–¥–µ—Ç –≥–æ—Ç–æ–≤–æ!",
        "–ó–∞–≥—Ä—É–∂–∞—é –æ—Ç—á–µ—Ç... ‚è≥",
        "–°–µ–π—á–∞—Å –ø–æ–¥–≥–æ—Ç–æ–≤–ª—é –≤–∞—à –æ—Ç—á–µ—Ç, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ –Ω–µ–º–Ω–æ–≥–æ! üöÄ",
        "–ò–¥–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö... üìä –ü–æ–¥–æ–∂–¥–∏—Ç–µ –Ω–µ–º–Ω–æ–≥–æ, —Å–∫–æ—Ä–æ –≤—Å—ë –±—É–¥–µ—Ç –≥–æ—Ç–æ–≤–æ!"
    ]
    iiko_session_token = context.user_data.get('iiko_session_token')
    iiko_server_address = context.user_data.get('iiko_server_address')
    if not iiko_session_token or not iiko_server_address:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–Ω–∞—á–∞–ª–∞ –∞–≤—Ç–æ—Ä–∏–∑—É–π—Ç–µ—Å—å –≤ iikoServer API –∫–æ–º–∞–Ω–¥–æ–π /start.")
        return

    loading_message = random.choice(LOADING_MESSAGES)
    await update.message.reply_text(loading_message)
    result = await get_average_check(iiko_server_address, iiko_session_token, start_date, end_date)
    period_str = f"{start_date.strftime('%d.%m.%Y')} - {end_date.strftime('%d.%m.%Y')}"
    if start_date == end_date:
        period_str = start_date.strftime('%d.%m.%Y')
    if result:
        response_text = (
            f"üìä *–°—Ä–µ–¥–Ω–∏–π —á–µ–∫ –∑–∞ {escape_markdown(period_str, version=2)}*\n\n"
            f"üßæ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–∫–∞–∑–æ–≤: *{escape_markdown(str(result['order_count']), version=2)}* —à—Ç\\.\n"
            f"üí∞ –û–±—â–∞—è —Å—É–º–º–∞: *{escape_markdown(f'{result['total_sum']:.2f}', version=2)}* —Ç–≥\\.\n"
            f"üìà –°—Ä–µ–¥–Ω–∏–π —á–µ–∫: *{escape_markdown(f'{result['avg_check']:.2f}', version=2)}* —Ç–≥\\.\n"
        )
        await update.message.reply_text(response_text, parse_mode=ParseMode.MARKDOWN_V2)
    else:
        await update.message.reply_text(
            f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –æ—Ç—á–µ—Ç '–°—Ä–µ–¥–Ω–∏–π —á–µ–∫' –∑–∞ –ø–µ—Ä–∏–æ–¥ *{escape_markdown(period_str, version=2)}*.",
            parse_mode=ParseMode.MARKDOWN_V2
        )

async def show_discounts_report(update, context, start_date, end_date):
    iiko_session_token = context.user_data.get('iiko_session_token')
    iiko_server_address = context.user_data.get('iiko_server_address')
    if not iiko_session_token or not iiko_server_address:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–Ω–∞—á–∞–ª–∞ –∞–≤—Ç–æ—Ä–∏–∑—É–π—Ç–µ—Å—å –≤ iikoServer API –∫–æ–º–∞–Ω–¥–æ–π /start.")
        return

    loading_message = random.choice(LOADING_MESSAGES)
    await update.message.reply_text(loading_message)
    discounts = await get_discounts_and_markups_report(iiko_server_address, iiko_session_token, start_date, end_date)
    period_str = f"{start_date.strftime('%d.%m.%Y')} - {end_date.strftime('%d.%m.%Y')}"
    if start_date == end_date:
        period_str = start_date.strftime('%d.%m.%Y')
    if discounts is not None and len(discounts) > 0:
        response_text = (
            f"üìä *–û—Ç—á–µ—Ç –ø–æ —Å–∫–∏–¥–∫–∞–º –∏ –Ω–∞–¥–±–∞–≤–∫–∞–º –∑–∞ {escape_markdown(period_str, version=2)}*\n"
        )
        for d in discounts:
            escaped_name = escape_markdown(str(d['name']), version=2)
            escaped_sum = escape_markdown(f"{d['sum']:.2f}", version=2)
            escaped_orders = escape_markdown(str(d['orders']), version=2)
            escaped_type = escape_markdown(d['type'], version=2)
            response_text += f"‚ñ™Ô∏è {escaped_type} `{escaped_name}`: *{escaped_sum}* —Ç–≥, —á–µ–∫–æ–≤: *{escaped_orders}* —à—Ç\\.\n"
        await update.message.reply_text(response_text, parse_mode=ParseMode.MARKDOWN_V2)
    else:
        await update.message.reply_text(
            f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –æ—Ç—á–µ—Ç –ø–æ —Å–∫–∏–¥–∫–∞–º –∏ –Ω–∞–¥–±–∞–≤–∫–∞–º –∑–∞ –ø–µ—Ä–∏–æ–¥ *{escape_markdown(period_str, version=2)}*.",
            parse_mode=ParseMode.MARKDOWN_V2
        )

async def show_dish_category_revenue_report(update: Update, context: ContextTypes.DEFAULT_TYPE, start_date: date, end_date: date) -> None:
    iiko_session_token = context.user_data.get('iiko_session_token')
    iiko_server_address = context.user_data.get('iiko_server_address')
    if not iiko_session_token or not iiko_server_address:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–Ω–∞—á–∞–ª–∞ –∞–≤—Ç–æ—Ä–∏–∑—É–π—Ç–µ—Å—å –≤ iikoServer API, –∏—Å–ø–æ–ª—å–∑—É—è –∫–æ–º–∞–Ω–¥—É `/start`.")
        return
    loading_message = random.choice(LOADING_MESSAGES)
    await update.message.reply_text(loading_message)
    revenue_data = await get_dish_category_revenue_from_iiko_server(iiko_server_address, iiko_session_token, start_date, end_date)
    period_str = f"{start_date.strftime('%d.%m.%Y')} - {end_date.strftime('%d.%m.%Y')}"
    if start_date == end_date:
        period_str = start_date.strftime('%d.%m.%Y')
    if revenue_data:
        response_text = (
            f"üìä *–û—Ç—á–µ—Ç: –í—ã—Ä—É—á–∫–∞ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º –±–ª—é–¥ –∑–∞ {escape_markdown(period_str, version=2)}*\n\n"
            f"üßæ –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–∫–∞–∑–æ–≤: *{escape_markdown(str(revenue_data['total_order_count_overall']), version=2)}* —à—Ç\\.\n"
            f"üí∞ –û–±—â–∞—è –≤—ã—Ä—É—á–∫–∞: *{escape_markdown(f'{revenue_data['total_revenue_overall']:.2f}', version=2)}* —Ç–≥\\.\n\n"
            f"_{escape_markdown('–î–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º –±–ª—é–¥:', version=2)}_\n"
        )
        sorted_categories = sorted(revenue_data['sales_by_category'].items(), key=lambda item: item[0])
        for category, amount in sorted_categories:
            escaped_category = escape_markdown(category, version=2)
            escaped_amount = escape_markdown(f'{amount:.2f}', version=2)
            response_text += f"‚ñ™Ô∏è {escaped_category}: *{escaped_amount}* —Ç–≥\\.\n"
        await update.message.reply_text(response_text, parse_mode=ParseMode.MARKDOWN_V2)
    else:
        await update.message.reply_text(
            f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –æ—Ç—á–µ—Ç '–í—ã—Ä—É—á–∫–∞ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º –±–ª—é–¥' –∑–∞ –ø–µ—Ä–∏–æ–¥ *{escape_markdown(period_str, version=2)}* —Å —Å–µ—Ä–≤–µ—Ä–∞ *{escape_markdown(iiko_server_address, version=2)}*\\.\n"
            "–í–æ–∑–º–æ–∂–Ω–æ, –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –∑–∞ —É–∫–∞–∑–∞–Ω–Ω—ã–π –ø–µ—Ä–∏–æ–¥, –∏–ª–∏ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –≤ API iikoServer\\. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏ –±–æ—Ç–∞\\.",
            parse_mode=ParseMode.MARKDOWN_V2,
        )

async def show_waiter_revenue_report(update: Update, context: ContextTypes.DEFAULT_TYPE, start_date: date, end_date: date) -> None:
    iiko_session_token = context.user_data.get('iiko_session_token')
    iiko_server_address = context.user_data.get('iiko_server_address')
    if not iiko_session_token or not iiko_server_address:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–Ω–∞—á–∞–ª–∞ –∞–≤—Ç–æ—Ä–∏–∑—É–π—Ç–µ—Å—å –≤ iikoServer API, –∏—Å–ø–æ–ª—å–∑—É—è –∫–æ–º–∞–Ω–¥—É `/start`.")
        return
    loading_message = random.choice(LOADING_MESSAGES)
    await update.message.reply_text(loading_message)
    revenue_data = await get_waiter_revenue_from_iiko_server(iiko_server_address, iiko_session_token, start_date, end_date)
    period_str = f"{start_date.strftime('%d.%m.%Y')} - {end_date.strftime('%d.%m.%Y')}"
    if start_date == end_date:
        period_str = start_date.strftime('%d.%m.%Y')
    if revenue_data:
        response_text = (
            f"üìä *–û—Ç—á–µ—Ç: –í—ã—Ä—É—á–∫–∞ –ø–æ –æ—Ñ–∏—Ü–∏–∞–Ω—Ç–∞–º –∑–∞ {escape_markdown(period_str, version=2)}*\n\n"
            f"üí∞ –û–±—â–∞—è –≤—ã—Ä—É—á–∫–∞: *{escape_markdown(f'{revenue_data['total_revenue_overall']:.2f}', version=2)}* —Ç–≥\\.\n\n"
            f"_{escape_markdown('–î–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ –æ—Ñ–∏—Ü–∏–∞–Ω—Ç–∞–º:', version=2)}_\n"
        )
        sorted_waiters = sorted(revenue_data['sales_by_waiter'].items(), key=lambda item: item[0])
        for waiter_name, amount in sorted_waiters:
            escaped_waiter_name = escape_markdown(waiter_name, version=2)
            escaped_amount = escape_markdown(f'{amount:.2f}', version=2)
            response_text += f"‚ñ™Ô∏è {escaped_waiter_name}: *{escaped_amount}* —Ç–≥\\.\n"
        await update.message.reply_text(response_text, parse_mode=ParseMode.MARKDOWN_V2)
    else:
        await update.message.reply_text(
            f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –æ—Ç—á–µ—Ç '–í—ã—Ä—É—á–∫–∞ –ø–æ –æ—Ñ–∏—Ü–∏–∞–Ω—Ç–∞–º' –∑–∞ –ø–µ—Ä–∏–æ–¥ *{escape_markdown(period_str, version=2)}* —Å —Å–µ—Ä–≤–µ—Ä–∞ *{escape_markdown(iiko_server_address, version=2)}*\\.\n"
            "–í–æ–∑–º–æ–∂–Ω–æ, –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –∑–∞ —É–∫–∞–∑–∞–Ω–Ω—ã–π –ø–µ—Ä–∏–æ–¥, –∏–ª–∏ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –≤ API iikoServer\\. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏ –±–æ—Ç–∞\\.",
            parse_mode=ParseMode.MARKDOWN_V2,
        )

async def show_order_type_revenue_report(update: Update, context: ContextTypes.DEFAULT_TYPE, start_date: date, end_date: date) -> None:
    iiko_session_token = context.user_data.get('iiko_session_token')
    iiko_server_address = context.user_data.get('iiko_server_address')
    if not iiko_session_token or not iiko_server_address:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–Ω–∞—á–∞–ª–∞ –∞–≤—Ç–æ—Ä–∏–∑—É–π—Ç–µ—Å—å –≤ iikoServer API, –∏—Å–ø–æ–ª—å–∑—É—è –∫–æ–º–∞–Ω–¥—É `/start`.")
        return
    loading_message = random.choice(LOADING_MESSAGES)
    await update.message.reply_text(loading_message)
    revenue_data = await get_order_type_revenue_from_iiko_server(iiko_server_address, iiko_session_token, start_date, end_date)
    period_str = f"{start_date.strftime('%d.%m.%Y')} - {end_date.strftime('%d.%m.%Y')}"
    if start_date == end_date:
        period_str = start_date.strftime('%d.%m.%Y')
    if revenue_data:
        response_text = (
            f"üìä *–û—Ç—á–µ—Ç: –í—ã—Ä—É—á–∫–∞ –ø–æ —Ç–∏–ø–∞–º –∑–∞–∫–∞–∑–æ–≤ –∑–∞ {escape_markdown(period_str, version=2)}*\n\n"
            f"üßæ –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–∫–∞–∑–æ–≤: *{escape_markdown(str(revenue_data['total_order_count_overall']), version=2)}* —à—Ç\\.\n"
            f"üí∞ –û–±—â–∞—è –≤—ã—Ä—É—á–∫–∞: *{escape_markdown(f'{revenue_data['total_revenue_overall']:.2f}', version=2)}* —Ç–≥\\.\n\n"
            f"_{escape_markdown('–î–µ—Ç–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ —Ç–∏–ø–∞–º –∑–∞–∫–∞–∑–æ–≤:', version=2)}_\n"
        )
        sorted_order_types = sorted(revenue_data['sales_by_order_type'].items(), key=lambda item: item[0])
        for order_type, amount in sorted_order_types:
            count = revenue_data['order_count_by_type'].get(order_type, 0)
            escaped_order_type = escape_markdown(order_type, version=2)
            escaped_amount = escape_markdown(f'{amount:.2f}', version=2)
            escaped_count = escape_markdown(str(count), version=2)
            response_text += f"‚ñ™Ô∏è {escaped_order_type}: *{escaped_amount}* —Ç–≥\\. \\({escaped_count} —à—Ç\\.\\)\n"
        await update.message.reply_text(response_text, parse_mode=ParseMode.MARKDOWN_V2)
    else:
        await update.message.reply_text(
            f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –æ—Ç—á–µ—Ç '–í—ã—Ä—É—á–∫–∞ –ø–æ —Ç–∏–ø–∞–º –∑–∞–∫–∞–∑–æ–≤' –∑–∞ –ø–µ—Ä–∏–æ–¥ *{escape_markdown(period_str, version=2)}* —Å —Å–µ—Ä–≤–µ—Ä–∞ *{escape_markdown(iiko_server_address, version=2)}*\\.\n"
            "–í–æ–∑–º–æ–∂–Ω–æ, –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –∑–∞ —É–∫–∞–∑–∞–Ω–Ω—ã–π –ø–µ—Ä–∏–æ–¥, –∏–ª–∏ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –≤ API iikoServer\\. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏ –±–æ—Ç–∞\\.",
            parse_mode=ParseMode.MARKDOWN_V2,
        )

async def show_summary_revenue_report(update: Update, context: ContextTypes.DEFAULT_TYPE, start_date: date, end_date: date) -> None:
    iiko_session_token = context.user_data.get('iiko_session_token')
    iiko_server_address = context.user_data.get('iiko_server_address')
    if not iiko_session_token or not iiko_server_address:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–Ω–∞—á–∞–ª–∞ –∞–≤—Ç–æ—Ä–∏–∑—É–π—Ç–µ—Å—å –≤ iikoServer API, –∏—Å–ø–æ–ª—å–∑—É—è –∫–æ–º–∞–Ω–¥—É `/start`.")
        return
    loading_message = random.choice(LOADING_MESSAGES)
    await update.message.reply_text(loading_message)
    summary_data = await get_summary_revenue_report_data(iiko_server_address, iiko_session_token, start_date, end_date)
    period_str = f"{start_date.strftime('%d.%m.%Y')} - {end_date.strftime('%d.%m.%Y')}"
    if start_date == end_date:
        period_str = start_date.strftime('%d.%m.%Y')
    response_text = f"üìä *–°–≤–æ–¥–Ω—ã–π –æ—Ç—á–µ—Ç –ø–æ –≤—ã—Ä—É—á–∫–µ –∑–∞ {escape_markdown(period_str, version=2)}*\n\n"
    if summary_data['pay_types_revenue']:
        response_text += (
            f"*_–û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:_*\n"
            f"üí∞ –û–±—â–∞—è –≤—ã—Ä—É—á–∫–∞: *{escape_markdown(f'{summary_data['pay_types_revenue']['total_revenue_overall']:.2f}', version=2)}* —Ç–≥\\.\n"
            f"üßæ –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–∫–∞–∑–æ–≤: *{escape_markdown(str(summary_data['pay_types_revenue']['total_order_count_overall']), version=2)}* —à—Ç\\.\n\n"
        )
    else:
        response_text += "_–û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞: –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –∏–ª–∏ –æ—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è_\\.\n\n"
    if summary_data['pay_types_revenue'] and summary_data['pay_types_revenue']['sales_by_payment_type']:
        response_text += f"*_–í—ã—Ä—É—á–∫–∞ –ø–æ —Ç–∏–ø–∞–º –æ–ø–ª–∞—Ç:_*\n"
        sorted_payment_types = sorted(summary_data['pay_types_revenue']['sales_by_payment_type'].items(), key=lambda item: item[0])
        for payment_type, amount in sorted_payment_types:
            escaped_payment_type = escape_markdown(payment_type, version=2)
            escaped_amount = escape_markdown(f'{amount:.2f}', version=2)
            response_text += f"‚ñ™Ô∏è {escaped_payment_type}: *{escaped_amount}* —Ç–≥\\.\n"
        response_text += "\n"
    else:
        response_text += "_–í—ã—Ä—É—á–∫–∞ –ø–æ —Ç–∏–ø–∞–º –æ–ø–ª–∞—Ç: –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –∏–ª–∏ –æ—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è_\\.\n\n"
    if summary_data['dish_category_revenue'] and summary_data['dish_category_revenue']['sales_by_category']:
        response_text += f"*_–í—ã—Ä—É—á–∫–∞ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º –±–ª—é–¥:_*\n"
        sorted_categories = sorted(summary_data['dish_category_revenue']['sales_by_category'].items(), key=lambda item: item[0])
        for category, amount in sorted_categories:
            escaped_category = escape_markdown(category, version=2)
            escaped_amount = escape_markdown(f'{amount:.2f}', version=2)
            response_text += f"‚ñ™Ô∏è {escaped_category}: *{escaped_amount}* —Ç–≥\\.\n"
        response_text += "\n"
    else:
        response_text += "_–í—ã—Ä—É—á–∫–∞ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º –±–ª—é–¥: –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –∏–ª–∏ –æ—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è_\\.\n\n"
    if summary_data['waiter_revenue'] and summary_data['waiter_revenue']['sales_by_waiter']:
        response_text += f"*_–í—ã—Ä—É—á–∫–∞ –ø–æ –æ—Ñ–∏—Ü–∏–∞–Ω—Ç–∞–º:_*\n"
        sorted_waiters = sorted(summary_data['waiter_revenue']['sales_by_waiter'].items(), key=lambda item: item[0])
        for waiter_name, amount in sorted_waiters:
            escaped_waiter_name = escape_markdown(waiter_name, version=2)
            escaped_amount = escape_markdown(f'{amount:.2f}', version=2)
            response_text += f"‚ñ™Ô∏è {escaped_waiter_name}: *{escaped_amount}* —Ç–≥\\.\n"
        response_text += "\n"
    else:
        response_text += "_–í—ã—Ä—É—á–∫–∞ –ø–æ –æ—Ñ–∏—Ü–∏–∞–Ω—Ç–∞–º: –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –∏–ª–∏ –æ—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è_\\.\n\n"
    if summary_data['order_type_revenue'] and summary_data['order_type_revenue']['sales_by_order_type']:
        response_text += f"*_–í—ã—Ä—É—á–∫–∞ –ø–æ —Ç–∏–ø–∞–º –∑–∞–∫–∞–∑–æ–≤:_*\n"
        sorted_order_types = sorted(summary_data['order_type_revenue']['sales_by_order_type'].items(), key=lambda item: item[0])
        for order_type, amount in sorted_order_types:
            count = summary_data['order_type_revenue']['order_count_by_type'].get(order_type, 0)
            escaped_order_type = escape_markdown(order_type, version=2)
            escaped_amount = escape_markdown(f'{amount:.2f}', version=2)
            escaped_count = escape_markdown(str(count), version=2)
            response_text += f"‚ñ™Ô∏è {escaped_order_type}: *{escaped_amount}* —Ç–≥\\. \\({escaped_count} —à—Ç\\.\\)\n"
        response_text += "\n"
    else:
        response_text += "_–í—ã—Ä—É—á–∫–∞ –ø–æ —Ç–∏–ø–∞–º –∑–∞–∫–∞–∑–æ–≤: –Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö –∏–ª–∏ –æ—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è_\\.\n\n"
    await update.message.reply_text(response_text, parse_mode=ParseMode.MARKDOWN_V2)




import xml.etree.ElementTree as ET

async def get_stores_dict(iiko_server_url: str, iiko_session_token: str) -> dict:
    url = f"{iiko_server_url}api/corporation/stores"
    params = {
        "key": iiko_session_token,
        "revisionFrom": -1
    }
    try:
        response = requests.get(url, params=params, timeout=30)
        response.raise_for_status()
        # –ü–∞—Ä—Å–∏–º XML!
        stores_dict = {}
        root = ET.fromstring(response.text)
        for store in root.findall(".//corporateItemDto"):
            store_id = store.find("id").text
            store_name = store.find("name").text
            stores_dict[store_id] = store_name
        return stores_dict
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∞ —Å–∫–ª–∞–¥–æ–≤: {e}, –æ—Ç–≤–µ—Ç: {getattr(response, 'text', '')}")
        return {}

async def get_top_dishes_report(iiko_server_url: str, iiko_session_token: str, start_date: date, end_date: date, top_n: int = 10) -> list | None:
    report_url = f"{iiko_server_url}api/v2/reports/olap"
    headers = {
        'Content-Type': 'application/json',
        'Cookie': f'key={iiko_session_token}'
    }
    payload = {
        "reportType": "SALES",
        "groupByRowFields": ["DishName"],
        "aggregateFields": ["DishDiscountSumInt", "DishAmountInt"],
        "filters": {
            "OpenDate.Typed": {
                "filterType": "DateRange",
                "periodType": "CUSTOM",
                "from": start_date.strftime("%Y-%m-%dT00:00:00.000"),
                "to": (end_date + timedelta(days=1)).strftime("%Y-%m-%dT00:00:00.000")
            },
            "DeletedWithWriteoff": {
                "filterType": "IncludeValues",
                "values": ["NOT_DELETED"]
            },
            "OrderDeleted": {
                "filterType": "IncludeValues",
                "values": ["NOT_DELETED"]
            }
        }
    }
    try:
        response = requests.post(report_url, headers=headers, json=payload, timeout=30)
        response.raise_for_status()
        data = response.json()
        if data and data.get('data') and isinstance(data['data'], list):
            # —Å–æ—Ä—Ç–∏—Ä—É–µ–º –±–ª—é–¥–∞ –ø–æ –≤—ã—Ä—É—á–∫–µ –ø–æ —É–±—ã–≤–∞–Ω–∏—é –∏ –±–µ—Ä–µ–º —Ç–æ–ø-N
            sorted_dishes = sorted(
                data['data'],
                key=lambda x: x.get('DishDiscountSumInt', 0.0),
                reverse=True
            )[:top_n]
            return sorted_dishes
        return None
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Ç–æ–ø–∞ –±–ª—é–¥: {e}, –æ—Ç–≤–µ—Ç: {getattr(response, 'text', '')}")
        return None

async def get_products_dict(iiko_server_url: str, iiko_session_token: str) -> dict:
    url = f"{iiko_server_url}api/v2/entities/products/list"
    params = {
        "key": iiko_session_token
    }
    headers = {
        'Content-Type': 'application/json'
        # –ù–ï –¥–æ–±–∞–≤–ª—è–π Cookie!
    }
    try:
        response = requests.post(url, headers=headers, params=params, json={}, timeout=60)
        response.raise_for_status()
        products = response.json()
        return {str(product['id']).strip(): product['name'] for product in products}
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∞ —Ç–æ–≤–∞—Ä–æ–≤: {e}, –æ—Ç–≤–µ—Ç: {getattr(response, 'text', '')}")
        return {}



async def show_store_balances_report(update, context) -> None:
    iiko_session_token = context.user_data.get('iiko_session_token')
    iiko_server_address = context.user_data.get('iiko_server_address')
    if not iiko_session_token or not iiko_server_address:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–Ω–∞—á–∞–ª–∞ –∞–≤—Ç–æ—Ä–∏–∑—É–π—Ç–µ—Å—å –≤ iikoServer API –∫–æ–º–∞–Ω–¥–æ–π /start.")
        return

    loading_message = random.choice(LOADING_MESSAGES)
    await update.message.reply_text(loading_message)
    balances = await get_store_balances(iiko_server_address, iiko_session_token)
    now = datetime.now(IIKO_TIMEZONE)
    date_str = now.strftime('%d.%m.%Y %H:%M')

    stores_dict = await get_stores_dict(iiko_server_address, iiko_session_token)
    products_dict = await get_products_dict(iiko_server_address, iiko_session_token)
    logger.info(f"products_dict sample: {list(products_dict.items())[:5]}")

    if balances:
        store_map = {}
        for item in balances:
            store = item['store']
            product = str(item['product']).strip()
            amount = item['amount']
            summ = item['sum']
            if store not in store_map:
                store_map[store] = []
            store_map[store].append((product, amount, summ))

        response = f"*–û—Å—Ç–∞—Ç–∫–∏ –ø–æ —Å–∫–ª–∞–¥–∞–º –Ω–∞ {escape_markdown(date_str, version=2)}:*\n\n"
        for store, products in store_map.items():
            store_name = stores_dict.get(store, store)
            response += f"*–°–∫–ª–∞–¥:* `{escape_markdown(str(store_name), version=2)}`\n"
            for product, amount, summ in products:
                logger.info(f"product: {product} -- name: {products_dict.get(product, 'NOT FOUND')}")
                product_name = products_dict.get(product, product)
                response += (
                    f"‚ñ´Ô∏è `{escape_markdown(str(product_name), version=2)}`: "
                    f"{escape_markdown(str(amount), version=2)} —à—Ç, "
                    f"{escape_markdown(str(summ), version=2)} —Ç–≥\n"
                )
            response += "\n"
        await update.message.reply_text(response, parse_mode=ParseMode.MARKDOWN_V2)
    else:
        await update.message.reply_text(
            f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –æ—Å—Ç–∞—Ç–∫–∏ –ø–æ —Å–∫–ª–∞–¥–∞–º –Ω–∞ {escape_markdown(date_str, version=2)}.",
            parse_mode=ParseMode.MARKDOWN_V2
        )

async def show_top_dishes_report(update, context, start_date, end_date, top_n=10):
    iiko_session_token = context.user_data.get('iiko_session_token')
    iiko_server_address = context.user_data.get('iiko_server_address')
    if not iiko_session_token or not iiko_server_address:
        await update.message.reply_text("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Å–Ω–∞—á–∞–ª–∞ –∞–≤—Ç–æ—Ä–∏–∑—É–π—Ç–µ—Å—å –≤ iikoServer API –∫–æ–º–∞–Ω–¥–æ–π /start.")
        return

    loading_message = random.choice(LOADING_MESSAGES)
    await update.message.reply_text(loading_message)
    top_dishes = await get_top_dishes_report(iiko_server_address, iiko_session_token, start_date, end_date, top_n)
    period_str = f"{start_date.strftime('%d.%m.%Y')} - {end_date.strftime('%d.%m.%Y')}"
    if start_date == end_date:
        period_str = start_date.strftime('%d.%m.%Y')
    if top_dishes is not None and len(top_dishes) > 0:
        title = escape_markdown(f"–¢–æ–ø-{top_n} –±–ª—é–¥ –ø–æ –≤—ã—Ä—É—á–∫–µ –∑–∞ {period_str}", version=2)
        response_lines = [f"üèÜ *{title}*"]
        for idx, dish in enumerate(top_dishes, 1):
            dish_name = escape_markdown(str(dish.get('DishName', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')), version=2)
            revenue = escape_markdown(f"{dish.get('DishDiscountSumInt', 0.0):.2f}", version=2)
            amount = escape_markdown(str(dish.get('DishAmountInt', 0)), version=2)
            # –≠–∫—Ä–∞–Ω–∏—Ä—É–µ–º —Ç–æ—á–∫—É, –º–∏–Ω—É—Å –∏ —Å–∫–æ–±–∫–∏!
            response_lines.append(f"{idx}\\.\ {dish_name} \\- {revenue} —Ç–≥ \\({amount} —à—Ç\\)")
        response_text = "\n".join(response_lines)

        await update.message.reply_text(response_text, parse_mode=ParseMode.MARKDOWN_V2)
    else:
        await update.message.reply_text(
            f"–ù–µ –Ω–∞–π–¥–µ–Ω–æ –¥–∞–Ω–Ω—ã—Ö –ø–æ –ø—Ä–æ–¥–∞–∂–∞–º –±–ª—é–¥ –∑–∞ –ø–µ—Ä–∏–æ–¥ *{escape_markdown(period_str, version=2)}*.",
            parse_mode=ParseMode.MARKDOWN_V2
        )

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user = update.effective_user
    context.user_data.clear()
    await update.message.reply_text(
        f"–ü—Ä–∏–≤–µ—Ç, {user.full_name}! üëã\n"
        "–Ø –±–æ—Ç, –∫–æ—Ç–æ—Ä—ã–π –ø–æ–º–æ–∂–µ—Ç —Ç–µ–±–µ –ø–æ–ª—É—á–∞—Ç—å –≤–∞–∂–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –∏–∑ iiko. "
        "–í–≤–µ–¥–∏—Ç–µ –∞–¥—Ä–µ—Å —Å–µ—Ä–≤–µ—Ä–∞ iiko (–Ω–∞–ø—Ä–∏–º–µ—Ä https://servername.iiko.it:443/resto/):",
        reply_markup=ReplyKeyboardRemove(),
    )
    context.user_data['state'] = ENTER_IIKO_SERVER_ADDRESS
    logger.info(f"User {user.id} started bot. State set to ENTER_IIKO_SERVER_ADDRESS.")

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    user_message = update.message.text
    user = update.effective_user
    state = context.user_data.get('state')
    if state == ENTER_IIKO_SERVER_ADDRESS:
        iiko_server_address = user_message.strip()
        if not (iiko_server_address.startswith('http://') or iiko_server_address.startswith('https://')):
            iiko_server_address = 'https://' + iiko_server_address
        if not iiko_server_address.endswith('/'):
            iiko_server_address += '/'
        if not iiko_server_address.endswith('/resto/'):
            iiko_server_address += 'resto/'
        context.user_data['iiko_server_address'] = iiko_server_address
        await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –ª–æ–≥–∏–Ω iikoOffice:")
        context.user_data['state'] = ENTER_IIKO_LOGIN
    elif state == ENTER_IIKO_LOGIN:
        iiko_login = user_message.strip()
        context.user_data['iiko_login'] = iiko_login
        await update.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –≤–∞—à –ø–∞—Ä–æ–ª—å iikoOffice:")
        context.user_data['state'] = ENTER_IIKO_PASSWORD
    elif state == ENTER_IIKO_PASSWORD:
        iiko_password = user_message.strip()
        iiko_password_hash = sha1_hash(iiko_password)
        server_url = context.user_data.get('iiko_server_address')
        login = context.user_data.get('iiko_login')
        iiko_session_token = await authenticate_iiko_server(server_url, login, iiko_password_hash)
        if iiko_session_token:
            context.user_data['iiko_session_token'] = iiko_session_token
            await send_main_menu_keyboard(update, context)
            context.user_data['state'] = MAIN_MENU
            if 'iiko_login' in context.user_data:
                del context.user_data['iiko_login']
        else:
            await update.message.reply_text(
                "–ù–µ —É–¥–∞–ª–æ—Å—å –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞—Ç—å—Å—è –≤ iikoServer API\\. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ **–ª–æ–≥–∏–Ω** –∏ **–ø–∞—Ä–æ–ª—å**\\. "
                "–ï—Å–ª–∏ –∞–¥—Ä–µ—Å —Å–µ—Ä–≤–µ—Ä–∞ —Ç–∞–∫–∂–µ –Ω–µ–≤–µ—Ä–µ–Ω, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É `/start` –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –≤–≤–æ–¥–∞ –≤—Å–µ—Ö –¥–∞–Ω–Ω—ã—Ö\\.\n"
                "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à –ª–æ–≥–∏–Ω iikoOffice —Å–Ω–æ–≤–∞:",
                parse_mode=ParseMode.MARKDOWN_V2,
            )
            context.user_data['state'] = ENTER_IIKO_LOGIN
    elif state == MAIN_MENU:
        await send_main_menu_keyboard(update, context)
    elif state == REPORT_MENU:
        await update.message.reply_text(
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –ø–µ—Ä–∏–æ–¥ –¥–ª—è –æ—Ç—á–µ—Ç–∞ –∏–ª–∏ –≤–µ—Ä–Ω–∏—Ç–µ—Å—å –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é\\.",
            parse_mode=ParseMode.MARKDOWN_V2,
        )
        report_type = context.user_data.get('current_report_type')
        if report_type:
            await send_period_selection_keyboard(update, context, report_type)
        else:
            await send_main_menu_keyboard(update, context)
            context.user_data['state'] = MAIN_MENU
    else:
        await update.message.reply_text("–ü—Ä–∏–≤–µ—Ç! –ß—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏ –∫–æ–º–∞–Ω–¥—É `/start`.")

async def send_main_menu_keyboard(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    keyboard = [
        [KeyboardButton("–°–≤–æ–¥–Ω—ã–π –æ—Ç—á–µ—Ç –ø–æ –≤—ã—Ä—É—á–∫–µ")],
        [KeyboardButton("–í—ã—Ä—É—á–∫–∞ –ø–æ —Ç–∏–ø–∞–º –æ–ø–ª–∞—Ç")],
        [KeyboardButton("–í—ã—Ä—É—á–∫–∞ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º –±–ª—é–¥")],
        [KeyboardButton("–í—ã—Ä—É—á–∫–∞ –ø–æ –æ—Ñ–∏—Ü–∏–∞–Ω—Ç–∞–º")],
        [KeyboardButton("–í—ã—Ä—É—á–∫–∞ –ø–æ —Ç–∏–ø–∞–º –∑–∞–∫–∞–∑–æ–≤")],
        [KeyboardButton("–¢–æ–ø –±–ª—é–¥ –ø–æ –≤—ã—Ä—É—á–∫–µ")],
        [KeyboardButton("–û—Ç–º–µ–Ω—ã –∏ —É–¥–∞–ª–µ–Ω–∏—è –±–ª—é–¥")],
        [KeyboardButton("–°—Ä–µ–¥–Ω–∏–π —á–µ–∫")],
        [KeyboardButton("–°–∫–∏–¥–∫–∏ –∏ –ù–∞–¥–±–∞–≤–∫–∏")],
        [KeyboardButton("–û—Å—Ç–∞—Ç–∫–∏ –ø–æ —Å–∫–ª–∞–¥–∞–º")],
        [KeyboardButton("/start")],
    ]

    
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=False)
    await update.message.reply_text(
        "–í—ã–±–µ—Ä–∏—Ç–µ –æ—Ç—á–µ—Ç:", reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN_V2
    )

async def send_period_selection_keyboard(update: Update, context: ContextTypes.DEFAULT_TYPE, report_name: str) -> None:
    context.user_data['current_report_type'] = report_name
    keyboard = [
        [KeyboardButton(f"{report_name}: –°–µ–≥–æ–¥–Ω—è")],
        [KeyboardButton(f"{report_name}: –í—á–µ—Ä–∞")],
        [KeyboardButton(f"{report_name}: –ù–µ–¥–µ–ª—è")],
        [KeyboardButton(f"{report_name}: –¢–µ–∫—É—â–∏–π –º–µ—Å—è—Ü")],
        [KeyboardButton(f"{report_name}: –ü—Ä–æ—à–ª—ã–π –º–µ—Å—è—Ü")],
        [KeyboardButton("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é")],
    ]
    reply_markup = ReplyKeyboardMarkup(keyboard, resize_keyboard=True, one_time_keyboard=True)
    await update.message.reply_text(
        f"–í—ã–±–µ—Ä–∏—Ç–µ –ø–µ—Ä–∏–æ–¥ –¥–ª—è –æ—Ç—á–µ—Ç–∞ \"*{escape_markdown(report_name, version=2)}*\":",
        reply_markup=reply_markup,
        parse_mode=ParseMode.MARKDOWN_V2,
    )
    context.user_data['state'] = REPORT_MENU

async def handle_button_text(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_message = update.message.text
    if context.user_data.get('state') == MAIN_MENU:
        if user_message == "–°–≤–æ–¥–Ω—ã–π –æ—Ç—á–µ—Ç –ø–æ –≤—ã—Ä—É—á–∫–µ":
            await send_period_selection_keyboard(update, context, "–°–≤–æ–¥–Ω—ã–π –æ—Ç—á–µ—Ç –ø–æ –≤—ã—Ä—É—á–∫–µ")
        elif user_message == "–í—ã—Ä—É—á–∫–∞ –ø–æ —Ç–∏–ø–∞–º –æ–ø–ª–∞—Ç":
            await send_period_selection_keyboard(update, context, "–í—ã—Ä—É—á–∫–∞ –ø–æ —Ç–∏–ø–∞–º –æ–ø–ª–∞—Ç")
        elif report_type == "–û—Ç–º–µ–Ω—ã –∏ —É–¥–∞–ª–µ–Ω–∏—è –±–ª—é–¥":
            await send_period_selection_keyboard(update, context, "–û—Ç–º–µ–Ω—ã –∏ —É–¥–∞–ª–µ–Ω–∏—è –±–ª—é–¥")
        elif user_message == "–í—ã—Ä—É—á–∫–∞ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º –±–ª—é–¥":
            await send_period_selection_keyboard(update, context, "–í—ã—Ä—É—á–∫–∞ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º –±–ª—é–¥")
        elif user_message == "–¢–æ–ø –±–ª—é–¥ –ø–æ –≤—ã—Ä—É—á–∫–µ":
            await send_period_selection_keyboard(update, context, "–¢–æ–ø –±–ª—é–¥ –ø–æ –≤—ã—Ä—É—á–∫–µ")
        elif user_message == "–°—Ä–µ–¥–Ω–∏–π —á–µ–∫":
            await send_period_selection_keyboard(update, context, "–°—Ä–µ–¥–Ω–∏–π —á–µ–∫")
        elif user_message == "–°–∫–∏–¥–∫–∏ –∏ –ù–∞–¥–±–∞–≤–∫–∏":
            await send_period_selection_keyboard(update, context, "–°–∫–∏–¥–∫–∏ –∏ –ù–∞–¥–±–∞–≤–∫–∏")
        elif user_message == "–í—ã—Ä—É—á–∫–∞ –ø–æ –æ—Ñ–∏—Ü–∏–∞–Ω—Ç–∞–º":
            await send_period_selection_keyboard(update, context, "–í—ã—Ä—É—á–∫–∞ –ø–æ –æ—Ñ–∏—Ü–∏–∞–Ω—Ç–∞–º")
        elif user_message == "–í—ã—Ä—É—á–∫–∞ –ø–æ —Ç–∏–ø–∞–º –∑–∞–∫–∞–∑–æ–≤":
            await send_period_selection_keyboard(update, context, "–í—ã—Ä—É—á–∫–∞ –ø–æ —Ç–∏–ø–∞–º –∑–∞–∫–∞–∑–æ–≤")
        elif user_message == "–û—Å—Ç–∞—Ç–∫–∏ –ø–æ —Å–∫–ª–∞–¥–∞–º":
            await show_store_balances_report(update, context)
            await send_main_menu_keyboard(update, context)
            context.user_data['state'] = MAIN_MENU
        elif user_message == "/start":
            await start(update, context)
        elif user_message == "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é":
            await send_main_menu_keyboard(update, context)
            context.user_data['state'] = MAIN_MENU
        else:
            await send_main_menu_keyboard(update, context)
    elif context.user_data.get('state') == REPORT_MENU:

        report_type = context.user_data.get('current_report_type')
        period_names = ["–°–µ–≥–æ–¥–Ω—è", "–í—á–µ—Ä–∞", "–ù–µ–¥–µ–ª—è", "–¢–µ–∫—É—â–∏–π –º–µ—Å—è—Ü", "–ü—Ä–æ—à–ª—ã–π –º–µ—Å—è—Ü"]
        selected_period = None
        for period_name in period_names:
            if period_name in user_message:
                selected_period = period_name
                break
        if user_message == "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é":
            await send_main_menu_keyboard(update, context)
            context.user_data['state'] = MAIN_MENU
            return
        if not selected_period:
            await update.message.reply_text(
                "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –ø–µ—Ä–∏–æ–¥ –∏–∑ –º–µ–Ω—é\\. "
                "–ò–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é' –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞\\.",
                parse_mode=ParseMode.MARKDOWN_V2,
            )
            await send_period_selection_keyboard(update, context, report_type)
            return
        start_date, end_date = get_period_dates(selected_period)
        if report_type == "–°–≤–æ–¥–Ω—ã–π –æ—Ç—á–µ—Ç –ø–æ –≤—ã—Ä—É—á–∫–µ":
            await show_summary_revenue_report(update, context, start_date, end_date)
        elif report_type == "–°—Ä–µ–¥–Ω–∏–π —á–µ–∫":
            await show_average_check_report(update, context, start_date, end_date)
        elif report_type == "–û—Ç–º–µ–Ω—ã –∏ —É–¥–∞–ª–µ–Ω–∏—è –±–ª—é–¥":
            await show_order_cancellations_report(update, context, start_date, end_date)
        elif report_type == "–¢–æ–ø –±–ª—é–¥ –ø–æ –≤—ã—Ä—É—á–∫–µ":
            await show_top_dishes_report(update, context, start_date, end_date, 10)
        elif report_type == "–°–∫–∏–¥–∫–∏ –∏ –ù–∞–¥–±–∞–≤–∫–∏":
            await show_discounts_report(update, context, start_date, end_date)
        elif report_type == "–í—ã—Ä—É—á–∫–∞ –ø–æ —Ç–∏–ø–∞–º –æ–ø–ª–∞—Ç":
            await show_pay_types_revenue_report(update, context, start_date, end_date)
        elif report_type == "–í—ã—Ä—É—á–∫–∞ –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º –±–ª—é–¥":
            await show_dish_category_revenue_report(update, context, start_date, end_date)
        elif report_type == "–í—ã—Ä—É—á–∫–∞ –ø–æ –æ—Ñ–∏—Ü–∏–∞–Ω—Ç–∞–º":
            await show_waiter_revenue_report(update, context, start_date, end_date)
        elif report_type == "–í—ã—Ä—É—á–∫–∞ –ø–æ —Ç–∏–ø–∞–º –∑–∞–∫–∞–∑–æ–≤":
            await show_order_type_revenue_report(update, context, start_date, end_date)
        await send_main_menu_keyboard(update, context)
        context.user_data['state'] = MAIN_MENU
    else:
        await handle_message(update, context)

def main() -> None:
    application = Application.builder().token("7674773820:AAF8lJD-okqbzkvbdUDbf_2mnrrognsroU0").build()
    application.add_handler(CommandHandler("start", start))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_button_text))
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    main()